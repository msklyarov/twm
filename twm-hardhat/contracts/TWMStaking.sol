/////////////////////////////////////////////////////////////////
// KYL // THE WATCHMAKER BANK // TWM STAKING CONTRACT // 2023 //
///////////////////////////////////////////////////////////////
// producer: KYL WATCHES LTD // Instagram: @kylwatchesltd   //
/////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//    ___  _______  __  _______   _______  ___  __   __  _______          ///
//   |   ||       ||  ||       | |       ||   ||  |_|  ||       |        ///
//   |   ||_     _||__||  _____| |_     _||   ||       ||    ___|       ///
//   |   |  |   |      | |_____    |   |  |   ||       ||   |___       ///
//   |   |  |   |      |_____  |   |   |  |   ||       ||    ___|     ///
//   |   |  |   |       _____| |   |   |  |   || ||_|| ||   |___     ///
//   |___|  |___|      |_______|   |___|  |___||_|   |_||_______|   ///
//                                                                 ///
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                  ///
//                                                                                 ./%@@@@@@@#,                    ///
//                                           .*(%&@@@@&&%%%##%%%&&@@@@%#*.    ,#@@&#/*,,.....,#@&,                ///
//                                     *%&@@&(*,.......................,*#@@@@#*******,%@@@@@@@@@@(              ///
//                                ,&@@&*.................................... (@@#,******,,,*/#@@@#              ///
//                            ,%@@#,............................................%@%*****/(//*,,..&&.           ///
//                         ,&@%*.,,,.............................................,%@#****//((#&@@@%.          ///
//                       (@&*,,,,,,,,..............................................,@&******,.../@&.         ///
//                     /@@,,,,,,,,,,,,...............................................%@(,/%#/,,..,%@,       ///
//      .*%@@@@&&&&%%%@@/,,,,,,,,,,,,,,,..............................................#@#,**#@@/,.*@@.     ///
//    (@@(,.........,&@*.,,,,,,,,,,,,,,,,............................(@(.............. (@(,**,&@,.,%@*    ///
//  .&@/..,/%&(.....#@/.,,,,,,,,,,,,,,,,,,.....................,(%@&/,..................#@(,**(@&.,%@*   ///
//  #@#&@@@@%,......&&,,,,,,,,,,,,,,,,,,,,,,.......... .*#@@@&(. ...............  .......&@/**(@@&*&@.  ///
// .#&(#@&,.../&#*,*@#.,,,,,,,,,,,,,,,,,,,,,,,*/#&@@&%(*..................,/%@@@@@(*.....,@&*,#@*/@&,  ///
//    %@*.,(@@#*,,.*@#.,,,,,,,,,.%&&&@@@&%%#/*,,......................*&@&#*...,@&#@&,..../@#*@%      ///
//    (@&@@%*******/@#.,,,,,,,,,,,,,,,,,,,,,,,,,....................#@&*.#@@@&/..,&@*......%@@&.      ///
//       @&****,(@@*&&.,,,,,,,,,,,,,,,,,,,,,,,,,,..................%@*.,&@@@@@@@@@@@@%* ...(@/        ///
//      .@&****@@/,.#@*.,,,,,,,,,,,,,,,,,,,,,,,,,,..............*@@%*(@@@@@@@@&&&&&@@@@@@&*,&@,       ///
//       %@/**/@@*,./@%.,,,,/%&@@@@&%%%&&@@&/,,.,,..............&&(@@@@@%@@####%##(((((%@@@@@@%.      ///
//        &@**,#@#,.,%@*.,,*%@@%************#@@@@#,............,&@@@@#(#&@@@&%###%@@@@#(((&@@@@(      ///
//        .%@#,/@@%,*(@%,,,%@@/,**,,/%@@@@@@@@@&#&@#.......... #@@@#(%@@%*/%@@@@@@&(/#@@%((#@@@@.     ///
//          ,@&/@&&@#*%@(,,,./@&&@@@@@@@&&@&&&@@@@@@@(......../@@@((&@&/%@@@@@@@*     *%@&(((@@@&     ///
//            .((. .%@&@@*,,,#@@@@#/%*,,,*@(.,,,#/*%@@@&,.....%@@%(%@@/&@@@@@@@@(.  ,%&/&@%((&@@@*    ///
//                    .(@@*/@@@&,,,,,&#.,,(*..*@/.,,,*@@@#....(@@&(%@&/@@@@@@@@@@@@@@@@/&@#((@@@@%    ///
//                      *@@@@@#%@%,.,,,,,,,,,,,,.. /@@/@@@%%@@@@@@%(&@%%@@@@@@@@@@@@@@/&@&((&@@@@&    ///
//                       #@@@(.,,.,,,,.,,,*(%&%/, .    ,@@@&#/,.#@@&(&@@#&@@@@@@@@@@#%@@#((@@@&/@&    ///
//                       %@@&.***,*##(*.&@@@@&,    ,,,,,@@@,.....*@@@&(#@@@&&&%%&&@@@&((#@@@@/.(@(    ///
//                       &@@@.          #@/*. ..       *@@&........,%@@@&#(((####(((#&@@@@&*..,&@.    ///
//                       (@@@*    (,   @%         #,   %@@(............%@@@@@@@@@@@@@@@#......(@/     ///
//                        #@@@((#,    (,            (&@@@#,...........*#&@%,,*//**............@%      ///
//                         *@@@@(   ,&*  .&*   %(  .#@@@&%*...............#@/./#&@@@&&@@@&%/,%@*      ///
//                           .&@@@@&%,   .@/   .#@@@@@#@@,,,.............,%@@%/,...%@%/...,*(%@@@&#*  ///
//                             /@@@@@@@@@@@@@@@@@@&*.,#@*.,,............(@%.,,&@/...../&@@@(.,#@@@(   ///
//                               /@&*..,*****,..,*(#%&&@@@&(*.........(@@*.....*&@#...,#@@(&@%,       ///
//                                 /@@/.,,,,*%@@%(/,...,,.,*#&@@@@@@@&(,.........*&@&&&/../@(         ///
//                                   ,&@%,(@@(,#@#,*,&@/*,**,................,(&@@(......,@&.         ///
//                                      %@@*,(@&/**,#@#*****,..,,,.*,.....#@@&* .........&@*         ////
//                                   .%@%**/@@%//**#@@%(*********//((#&@@%*..*,.........#@(         /////
//                                .@@@@@@@@&%@@#(#(,.,/%%%%###((/**,.....,(@%,....... (@/          //////
//                                             *@@(,,,,,,,,,,,,,(@&&&&@@@#/...........%@/         ///////
//                                                %@@,.,,,,,,,,,,,,,,,,,........... /@@.         ////////
//                                                  *&@%,,,,,,,,,,,,,,.........,/&@@#.          /////////
//                                                     ,%@&(,........,,*/#%@@@%(,              //////////
//                                                         *%@@@@@@@&%(*,.                    ///////////
//                                                                                           ////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                       ////////
//  ████████╗██╗  ██╗███████╗    ██╗    ██╗ █████╗ ████████╗ ██████╗██╗  ██╗███╗   ███╗ █████╗ ██╗  ██╗███████╗██████╗       ///
//  ╚══██╔══╝██║  ██║██╔════╝    ██║    ██║██╔══██╗╚══██╔══╝██╔════╝██║  ██║████╗ ████║██╔══██╗██║ ██╔╝██╔════╝██╔══██╗     ///
//     ██║   ███████║█████╗      ██║ █╗ ██║███████║   ██║   ██║     ███████║██╔████╔██║███████║█████╔╝ █████╗  ██████╔╝    ///
//     ██║   ██╔══██║██╔══╝      ██║███╗██║██╔══██║   ██║   ██║     ██╔══██║██║╚██╔╝██║██╔══██║██╔═██╗ ██╔══╝  ██╔══██╗   ///
//     ██║   ██║  ██║███████╗    ╚███╔███╔╝██║  ██║   ██║   ╚██████╗██║  ██║██║ ╚═╝ ██║██║  ██║██║  ██╗███████╗██║  ██║  ///
//     ╚═╝   ╚═╝  ╚═╝╚══════╝     ╚══╝╚══╝ ╚═╝  ╚═╝   ╚═╝    ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝ ///
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SPDX-License-Identifier: MIT
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

pragma solidity ^0.8.7;

contract TWMStaking is Ownable, ReentrancyGuard {
    IERC721 public FirstCollection;
    IERC721 public SecondCollection;
    IERC721 public ThirdCollection;

    uint256 public constant SECONDS_IN_DAY = 24 * 60 * 60;

    address public signerAddress;

    bool public stakingLaunched;
    bool public depositPaused;

    struct Staker {
        uint256 currentYield;
        uint256 accumulatedAmount;
        uint256 lastCheckpoint;
        uint256[] stakedFIRST;
        uint256[] stakedSECOND;
        uint256[] stakedTHIRD;
    }

    enum ContractTypes {
        FIRSTCOL,
        SECONDCOL,
        THIRDCOL
    }

    mapping(address => uint256) public _baseRates;
    mapping(address => Staker) private _stakers;
    mapping(address => mapping(uint256 => address)) private _ownerOfToken;
    mapping(address => ContractTypes) private _contractTypes;
    mapping(address => mapping(uint256 => uint256)) private _tokensMultiplier;

    event Deposit(
        address indexed staker,
        address contractAddress,
        uint256 tokensAmount
    );
    event Withdraw(
        address indexed staker,
        address contractAddress,
        uint256 tokensAmount
    );
    event AutoDeposit(
        address indexed contractAddress,
        uint256 tokenId,
        address indexed owner
    );
    event WithdrawStuckERC721(
        address indexed receiver,
        address indexed tokenAddress,
        uint256 indexed tokenId
    );

    constructor(address _twm, address _signer) {
        FirstCollection = IERC721(_twm);
        _contractTypes[_twm] = ContractTypes.FIRSTCOL;
        _baseRates[_twm] = 25 ether;
        signerAddress = _signer;
    }

    function deposit(
        address contractAddress,
        uint256[] memory tokenIds,
        uint256[] memory tokenTraits,
        bytes calldata signature
    ) public nonReentrant {
        require(!depositPaused, "Deposit paused");
        require(stakingLaunched, "Staking is not launched yet");
        require(
            (contractAddress != address(0) &&
                contractAddress == address(FirstCollection)) ||
                contractAddress == address(SecondCollection) ||
                contractAddress == address(ThirdCollection),
            "Unknown contract"
        );
        ContractTypes contractType = _contractTypes[contractAddress];

        if (tokenTraits.length > 0) {
            require(
                _validateSignature(
                    signature,
                    contractAddress,
                    tokenIds,
                    tokenTraits
                ),
                "Invalid data provided"
            );
            _setTokensValues(contractAddress, tokenIds, tokenTraits);
        }

        Staker storage user = _stakers[_msgSender()];
        uint256 newYield = user.currentYield;

        for (uint256 i; i < tokenIds.length; i++) {
            require(
                IERC721(contractAddress).ownerOf(tokenIds[i]) == _msgSender(),
                "Not the owner"
            );
            IERC721(contractAddress).safeTransferFrom(
                _msgSender(),
                address(this),
                tokenIds[i]
            );

            _ownerOfToken[contractAddress][tokenIds[i]] = _msgSender();

            newYield += getTokenYield(contractAddress, tokenIds[i]);

            if (contractType == ContractTypes.FIRSTCOL) {
                user.stakedFIRST.push(tokenIds[i]);
            }
            if (contractType == ContractTypes.SECONDCOL) {
                user.stakedSECOND.push(tokenIds[i]);
            }
            if (contractType == ContractTypes.THIRDCOL) {
                user.stakedTHIRD.push(tokenIds[i]);
            }
        }

        accumulate(_msgSender());
        user.currentYield = newYield;

        emit Deposit(_msgSender(), contractAddress, tokenIds.length);
    }

    function withdraw(
        address contractAddress,
        uint256[] memory tokenIds
    ) public nonReentrant {
        require(
            (contractAddress != address(0) &&
                contractAddress == address(FirstCollection)) ||
                contractAddress == address(SecondCollection) ||
                contractAddress == address(ThirdCollection),
            "Unknown contract"
        );
        ContractTypes contractType = _contractTypes[contractAddress];
        Staker storage user = _stakers[_msgSender()];
        uint256 newYield = user.currentYield;

        for (uint256 i; i < tokenIds.length; i++) {
            require(
                IERC721(contractAddress).ownerOf(tokenIds[i]) == address(this),
                "Not the owner"
            );

            _ownerOfToken[contractAddress][tokenIds[i]] = address(0);

            if (user.currentYield != 0) {
                uint256 tokenYield = getTokenYield(
                    contractAddress,
                    tokenIds[i]
                );
                newYield -= tokenYield;
            }

            if (contractType == ContractTypes.FIRSTCOL) {
                user.stakedFIRST = _moveTokenInTheList(
                    user.stakedFIRST,
                    tokenIds[i]
                );
                user.stakedFIRST.pop();
            }
            if (contractType == ContractTypes.SECONDCOL) {
                user.stakedSECOND = _moveTokenInTheList(
                    user.stakedSECOND,
                    tokenIds[i]
                );
                user.stakedSECOND.pop();
            }
            if (contractType == ContractTypes.THIRDCOL) {
                user.stakedTHIRD = _moveTokenInTheList(
                    user.stakedTHIRD,
                    tokenIds[i]
                );
                user.stakedTHIRD.pop();
            }

            IERC721(contractAddress).safeTransferFrom(
                address(this),
                _msgSender(),
                tokenIds[i]
            );
        }

        if (user.stakedFIRST.length == 0 && user.stakedSECOND.length == 0) {
            newYield = 0;
        }

        accumulate(_msgSender());
        user.currentYield = newYield;

        emit Withdraw(_msgSender(), contractAddress, tokenIds.length);
    }

    function getAccumulatedAmount(
        address staker
    ) external view returns (uint256) {
        return _stakers[staker].accumulatedAmount + getCurrentReward(staker);
    }

    function getTokenYield(
        address contractAddress,
        uint256 tokenId
    ) public view returns (uint256) {
        uint256 tokenYield = _tokensMultiplier[contractAddress][tokenId];
        if (tokenYield == 0) {
            tokenYield = _baseRates[contractAddress];
        }

        return tokenYield;
    }

    function getStakerYield(address staker) public view returns (uint256) {
        return _stakers[staker].currentYield;
    }

    function getStakerTokens(
        address staker
    )
        public
        view
        returns (uint256[] memory, uint256[] memory, uint256[] memory)
    {
        return (
            _stakers[staker].stakedFIRST,
            _stakers[staker].stakedSECOND,
            _stakers[staker].stakedTHIRD
        );
    }

    function isMultiplierSet(
        address contractAddress,
        uint256 tokenId
    ) public view returns (bool) {
        return _tokensMultiplier[contractAddress][tokenId] > 0;
    }

    function _moveTokenInTheList(
        uint256[] memory list,
        uint256 tokenId
    ) internal pure returns (uint256[] memory) {
        uint256 tokenIndex = 0;
        uint256 lastTokenIndex = list.length - 1;
        uint256 length = list.length;

        for (uint256 i = 0; i < length; i++) {
            if (list[i] == tokenId) {
                tokenIndex = i + 1;
                break;
            }
        }
        require(tokenIndex != 0, "msg.sender is not the owner");

        tokenIndex -= 1;

        if (tokenIndex != lastTokenIndex) {
            list[tokenIndex] = list[lastTokenIndex];
            list[lastTokenIndex] = tokenId;
        }

        return list;
    }

    function _validateSignature(
        bytes calldata signature,
        address contractAddress,
        uint256[] memory tokenIds,
        uint256[] memory tokenTraits
    ) internal view returns (bool) {
        bytes32 dataHash = keccak256(
            abi.encodePacked(contractAddress, tokenIds, tokenTraits)
        );
        bytes32 message = ECDSA.toEthSignedMessageHash(dataHash);

        address receivedAddress = ECDSA.recover(message, signature);
        return (receivedAddress != address(0) &&
            receivedAddress == signerAddress);
    }

    function _setTokensValues(
        address contractAddress,
        uint256[] memory tokenIds,
        uint256[] memory tokenTraits
    ) internal {
        require(tokenIds.length == tokenTraits.length, "Wrong arrays provided");
        for (uint256 i; i < tokenIds.length; i++) {
            if (tokenTraits[i] != 0) {
                _tokensMultiplier[contractAddress][tokenIds[i]] = tokenTraits[
                    i
                ];
            }
        }
    }

    function getCurrentReward(address staker) public view returns (uint256) {
        Staker memory user = _stakers[staker];
        if (user.lastCheckpoint == 0) {
            return 0;
        }
        return
            ((block.timestamp - user.lastCheckpoint) * user.currentYield) /
            SECONDS_IN_DAY;
    }

    function accumulate(address staker) internal {
        _stakers[staker].accumulatedAmount += getCurrentReward(staker);
        _stakers[staker].lastCheckpoint = block.timestamp;
    }

    /**
     * @dev Returns token owner address (returns address(0) if token is not inside the gateway)
     */
    function ownerOf(
        address contractAddress,
        uint256 tokenId
    ) public view returns (address) {
        return _ownerOfToken[contractAddress][tokenId];
    }

    function setFirstContract(
        address _first,
        uint256 _baseReward
    ) public onlyOwner {
        FirstCollection = IERC721(_first);
        _contractTypes[_first] = ContractTypes.FIRSTCOL;
        _baseRates[_first] = _baseReward;
    }

    function setSecondContract(
        address _second,
        uint256 _baseReward
    ) public onlyOwner {
        SecondCollection = IERC721(_second);
        _contractTypes[_second] = ContractTypes.SECONDCOL;
        _baseRates[_second] = _baseReward;
    }

    function setThirdContract(
        address _third,
        uint256 _baseReward
    ) public onlyOwner {
        ThirdCollection = IERC721(_third);
        _contractTypes[_third] = ContractTypes.THIRDCOL;
        _baseRates[_third] = _baseReward;
    }

    /**
     * @dev Function allows admin withdraw ERC721 in case of emergency.
     */
    function emergencyWithdraw(
        address tokenAddress,
        uint256[] memory tokenIds
    ) public onlyOwner {
        require(tokenIds.length <= 50, "50 is max per tx");
        pauseDeposit(true);
        for (uint256 i; i < tokenIds.length; i++) {
            address receiver = _ownerOfToken[tokenAddress][tokenIds[i]];
            if (
                receiver != address(0) &&
                IERC721(tokenAddress).ownerOf(tokenIds[i]) == address(this)
            ) {
                IERC721(tokenAddress).transferFrom(
                    address(this),
                    receiver,
                    tokenIds[i]
                );
                emit WithdrawStuckERC721(receiver, tokenAddress, tokenIds[i]);
            }
        }
    }

    /**
     * @dev Function allows to pause deposits if needed. Withdraw remains active.
     */
    function pauseDeposit(bool _pause) public onlyOwner {
        depositPaused = _pause;
    }

    /**
     * @dev Function allows to pause deposits if needed. Withdraw remains active.
     */
    function updateSignerAddress(address _signer) public onlyOwner {
        signerAddress = _signer;
    }

    function launchStaking() public onlyOwner {
        require(!stakingLaunched, "Staking has been launched already");
        stakingLaunched = true;
    }

    function updateBaseYield(
        address _contract,
        uint256 _yield
    ) public onlyOwner {
        _baseRates[_contract] = _yield;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure returns (bytes4) {
        return
            bytes4(
                keccak256("onERC721Received(address,address,uint256,bytes)")
            );
    }
}
